<!DOCTYPE html>
<html>
  <head>
    <title>GrooveStomp</title>
    <link rel="stylesheet" type="text/css" href="/css/style.css">
  </head>
  <body>
    <div id="navigation">
      <ul>
        <li><a href="/">Home</a></li>
        <li><a href="/tags">Post Tags</a></li>
        <li><a href="/projects">Projects</a></li>
        <li><a href="/about">About</a></li>
        <li><a href="/index.xml">Rss</a></li>
      </ul>
    </div>

<div id="content-container">
  <div class="post">
    <div class="float-container">
      <h1>RISC-V, Go and QEMU</h1>
      <span class="date">2019-02-13</span>
    </div>
    

<p>I finally took the opportunity to jump back into RISC-V, Go and QEMU as a followup to my previous exploration.<sup><a href="#2019-02-13_ref1">1</a></sup></p>

<p>I had a difficult time understanding exactly what was required to run my compiled Go program in QEMU.
Let&rsquo;s take a look at the instructions.<sup><a href="#2019-02-13_ref2">2</a></sup></p>

<blockquote>
<p>Compile and run in qemu-riscv64 (which is expected to be in PATH):</p>

<pre><code>$ GOARCH=riscv GOOS=linux go run ../riscvtest/add.go
</code></pre>

<p>Build:</p>

<pre><code>$ GOARCH=riscv GOOS=linux go build ../riscvtest/add.go
</code></pre>
</blockquote>

<p>I was confused by was the mention of <code>qemu-riscv64</code> being in <code>PATH</code>.</p>

<p>The qemu-riscv instructions I followed<sup><a href="#2019-02-13_ref3">3</a></sup> didn&rsquo;t make any particular mention of a standalone <code>qemu-riscv64</code> executable, and there&rsquo;s all those parameters for block devices and whatnot.</p>

<p>Well, if I just take a look at my riscv-qemu dir:</p>

<pre><code>↳ ls | grep riscv
riscv32-linux-user
riscv32-linux-user-config-devices.mak.d
riscv32-softmmu
riscv32-softmmu-config-devices.mak.d
riscv64-linux-user
riscv64-linux-user-config-devices.mak.d
riscv64-softmmu
riscv64-softmmu-config-devices.mak.d
</code></pre>

<p>Aha! Something!</p>

<p>In fact, there is exactly a <code>qemu-riscv64</code> executable:</p>

<pre><code>↳ find . -name 'qemu-riscv64'
./riscv64-linux-user/qemu-riscv64
</code></pre>

<p>So now it&rsquo;s a piece of cake to run the RISC-V executable built from Go:</p>

<pre><code>↳ pwd
/home/aaron/code/riscv-go/src

↳ GOARCH=riscv GOOS=linux go build ../riscvtest/add.go

↳ ~/code/riscv-qemu/riscv64-linux-user/qemu-riscv64 ./add
Aaron: 12

↳ echo $?
12
</code></pre>

<p>I modified the program to print out like that because I didn&rsquo;t know offhand how to check the exit status of an executable. Turns out you just <code>echo $?</code> and it works!</p>

<p>But that&rsquo;s not all. It wasn&rsquo;t at all clear to me what was going on, so I started doing some searching and stumbled upon this<sup><a href="#2019-02-13_ref4">4</a></sup> explanatory post:</p>

<blockquote>
<p>There are three families of targets in QEMU:</p>

<p>User-mode emulation, where QEMU provides an AEE (Application Execution Environment). In this mode, QEMU itself acts as the supervisor &ndash; in other words, when QEMU sees an ecall it will decode the syscall number/arguments, perform the system call, and then return to emulating instructions. QEMU&rsquo;s user-mode emulation is thus tied to a specific supervisor&rsquo;s ABI, with the only instance I&rsquo;ve seen in RISC-V land being Linux.</p>

<p>Soft MMU, where QEMU provides an MEE (Machine Execution Environment). In this mode the entire software stack is run as if it was running on a full RISC-V system with QEMU providing emulated devices &ndash; in other words, when QEMU sees an ecall it will start emulating code at the trap vector. Here QEMU doesn&rsquo;t need to know anything about the supervisor as the exact supervisor code is running.</p>

<p>Hardware virtualization, where QEMU provides a HEE (Hypervisor Execution Environment) while relying on hardware emulation to provide better performance. We don&rsquo;t have this working on RISC-V yet (as of October 2018), but there are specifications in progress along with early implementation work.</p>

<p>If you see ecall instructions in userspace just magicly working, then you&rsquo;re probably running in user-mode emulation.</p>
</blockquote>

<p>Ah, very interesting!</p>

<p>That led me nearly directly to sections 3<sup><a href="#2019-02-13_ref5">5</a></sup>, 4<sup><a href="#2019-02-13_ref6">6</a></sup> and 5<sup><a href="#2019-02-13_ref7">7</a></sup> of the QEMU documentation, covering that StackOverflow post.
Section 5, directly led me to finally understanding how to run my Go program built for RISC-V architecture.</p>

<p>So this is very interesting to me. As I understand it, QEMU is running in &ldquo;user space emulator&rdquo; mode, acting as the operating system, implementing system calls.
It seems like the riscv-go page even mentions this<sup><a href="#2019-02-13_ref8">8</a></sup>:</p>

<blockquote>
<p>Spike plus pk support only a small subset of Linux syscalls and will not be capable of supporting the full Go runtime.</p>

<p>The RISC-V QEMU port supports a much wider set of syscalls with its &ldquo;User Mode Simulation&rdquo;. See Method 2 in the QEMU README for instructions.</p>
</blockquote>

<p>However, I&rsquo;ll be honest: I don&rsquo;t know what &ldquo;Spike plus pk&rdquo; is, so I essentially just ignored that part on first read.</p>

<p>Unfortunately, it seems like this is a long ways from running a native Go executable on simulated RISC-V hardware.  I think. I&rsquo;m honestly not super clear on System Emulator mode vs. Guest Agent mode vs. User Space Emulator mode yet.  I have a vague understanding but will need to explore more.
I think running the Fedora image as I did before is closer to running a &ldquo;true&rdquo; RISC-V system.</p>

<p>Here&rsquo;s the command:</p>

<pre><code>qemu-system-riscv64 \
   -nographic \
   -machine virt \
   -smp 4 \
   -m 2G \
   -kernel bbl \
   -object rng-random,filename=/dev/urandom,id=rng0 \
   -device virtio-rng-device,rng=rng0 \
   -append &quot;console=ttyS0 ro root=/dev/vda&quot; \
   -device virtio-blk-device,drive=hd0 \
   -drive file=stage4-disk.img,format=raw,id=hd0 \
   -device virtio-net-device,netdev=usernet \
   -netdev user,id=usernet,hostfwd=tcp::10000-:22
</code></pre>

<p>So it&rsquo;s running in System Emulator mode (I&rsquo;m guessing, based on the executable invocation) which should be as close as we can get.</p>

<p>Hopefully I can put some more time into better understanding this stuff.  It&rsquo;s been interesting!</p>

<hr />

<h4 id="footnotes">Footnotes</h4>

<p><sub><sup id="2019-02-13_ref1">1</sup><a href="/2018/12/07/qemu-riscv/">QEMU and RISC-V</a></sub><br />
<sub><sup id="2019-02-13_ref2">2</sup><a href="https://github.com/riscv/riscv-go#quick-start">riscv-go Quick Start</a></sub><br />
<sub><sup id="2019-02-13_ref3">3</sup><a href="https://wiki.qemu.org/Documentation/Platforms/RISCV">qemu-riscv Wiki</a></sub><br />
<sub><sup id="2019-02-13_ref4">4</sup><a href="https://stackoverflow.com/a/52807871">QEMU targets</a></sub><br />
<sub><sup id="2019-02-13_ref5">5</sup><a href="https://qemu.weilnetz.de/doc/qemu-doc.html#QEMU-System-emulator-for-non-PC-targets">QEMU System Emulator</a></sub><br />
<sub><sup id="2019-02-13_ref6">6</sup><a href="https://qemu.weilnetz.de/doc/qemu-doc.html#QEMU-Guest-Agent">QEMU Guest Agent</a></sub><br />
<sub><sup id="2019-02-13_ref7">7</sup><a href="https://qemu.weilnetz.de/doc/qemu-doc.html#QEMU-User-space-emulator">QEMU User Space Emulator</a></sub><br />
<sub><sup id="2019-02-13_ref8">8</sup><a href="https://github.com/riscv/riscv-go#qemu">riscv-go QEMU</a></sub><br /></p>

  </div>

  <div id="pagination">
    <ul>
      
      <li><a href="http://127.0.0.1:1234/2019/02/27/vps-learning/">Older</a></li>
      
      
      <li><a href="http://127.0.0.1:1234/2018/12/12/chkpass/">Newer</a></li>
      
    </ul>
  </div>
</div>
  </body>
</html>

